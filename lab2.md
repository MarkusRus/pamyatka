---
title: 'Лабораторная работа 2'
author: 'А.В. Родионов'
fontsize: '14pt'
geometry: 'margin=2cm'
paper: 'a4'
lang: 'russian'
template: 'default.html'
---

# Ветвление

В предыдущей лабораторной работе был рассмотрен последовательный процесс сохранения изменений в
репозитории Git. Реальный процесс разработки предполагает одновременную работу сразу над несколькими
версиями программного продукта. Как правило, имеется основная, стабильная линия развития проекта, в
которую изменения добавляются только после тестирования и опытной эксплуатации. Параллельно с ней
существует одна или более рабочих версий, которые служат для внесения в продукт новых возможностей и
характеристик. Рабочие версии после тестирования и проверки могут быть объединены со стабильной, в
результате чего выпускается новая версия программного обеспечения. Затем цикл разработки
продолжается, причем, помимо работы над новыми рабочими версиями, возможны срочные изменения в
стабильной, например, если ошибка в ней обнаружилась уже после начала эксплуатации. В Git
такие параллельные линии развития проекта называются ветками. Ветки позволяют хранить параллельную
историю нескольких направлений развития проекта, с возможностью объединять изменения из нескольких
веток, ответвлять от них новые и переносить ветки на новые начальные точки.

## Реализация веток в Git

Каждый коммит в Git представляет собой набор изменений и одну или более ссылок на предыдущие
коммиты, от которых отсчитываются собственно изменения. Каждый коммит уникально идентифицируется
контрольной суммой изменений (хэшем), вычисленной по алгоритму SHA-1, благодаря чему его всегда
можно найти в репозитории и привести рабочую директорию проекта в состояние, которое ему
соответствует. Для этого Git находит все родительские коммиты вплоть до самого первого и
последовательно их применяет к исходному состоянию проекта. Ветка в Git представляет собой
именованный указатель на коммит. Физически, это файл, у которого есть имя, совпадающее с названием
ветки, а содержимое которого представляет собой хэш коммита. Ветка занимает мало места на диске, их
можно создавать в практически неограниченном количестве, а так же переименовывать или удалять, не
рискуя потерять какой-либо коммит из репозитория. При инициализации пустого репозитория
автоматически создается ветка с названием `master`. Как правило, `master` отслеживает стабильную
линию развития продукта, а новые возможности добавляются в побочных ветках, одну из которых
традиционно называют `develop`.

Для того, чтобы отслеживать, на какой ветке в данный момент времени находится проект, Git
поддерживает ветку-указатель `HEAD`. Она совпадает с последним коммитом текущей ветки проекта. При
добавлении очередного коммита, его хэш сохраняется как в ветке, так и в указателе HEAD. Команда `git
checkout`, если ей передать имя ветки или первые цифры хэша коммита, переводит рабочую директорию
проекта в соответствующее состояние и устанавливает соответствующим образом `HEAD`. Если `HEAD`
указывает не на ветку, а на произвольный коммит, такое состояние проекта называется "безголовым"
(headless). Изменения в таком состоянии будут также продвигать `HEAD`, но не будут связаны ни с
одной из веток. Из этого состояния можно вернуться в одну из имеющихся веток, тогда коммиты будут
"забыты", либо создать новую ветку от последнего "безголового" коммита. При необходимости, можно
вернуться к "забытому" коммиту, для этого нужно найти его хэш с помощью команды `git reflog` или
`git log -g`, затем перейти на него командой `git checkout <хэш>` или создать для него новую ветку.

## Создание веток

Ветка создается путем копирования текущего указателя `HEAD` с присвоением копии нового имени. В
любом состоянии проекта можно создать ветку командой `git branch <имя ветки>`. Дополнительным
параметром может быть хэш или иной идентификатор коммита, в том числе имя другой ветки. В этом
случае ветка будет иметь свое начало от заданного во втором параметре коммита или ветки. Команда
`git branch` создает новую ветку, но не переносит на нее `HEAD`. Чтобы перейти на новую ветку и
начать добавлять в нее коммиты, нужно выполнить `git checkout <имя новой ветки>`. Так как создание
новой ветки и переход в нее являются достаточно частой комбинацией действий, команда `git checkout
-b <имя ветки>` позволяет создать новую ветку и сразу переключиться на нее. Если ветка с заданным
именем уже существует, команда завершится ошибкой. В любой момент имеющиеся в репозитории ветки
можно просмотреть командой `git branch` без параметров.

## Слияние веток

В определенный момент работа, проделанная над побочной веткой, должна быть перенесена в основную.
Например, если изменения велись в ветке `develop`, а необходимо добавить их в ветку `master`, нужно
перейти в последнюю командой `git checkout master`, а затем выполнить слияние командой `git merge
develop`. Если, во время работы над `develop`, изменения в `master` не вносились, слияние
представляет собой просто перенос указателя ветки `master` на последний коммит в `develop`. Такое
слияние называется перемоткой вперед (fast forward) и не образует дополнительного коммита. В сложных
проектах, для того, чтобы отслеживать последствия слияний, имеет смысл даже для перемоток вперед
создавать новы коммит. Для этого можно использовать команду `git merge` с флагом `--no-ff`, например
`git merge develop --no-ff`. Для такого слияния коммит будет создан и автоматически отмечен записью
в журнале. Ветка, которая имеет не только родительские коммиты, но и своим последним коммитом
вливается в историю другой ветки, называется "слитой" (merged). Такую ветку можно безболезненно
удалить, ее коммиты не будут утеряны, т.к. их история продолжается в другой ветке.

## Удаление веток

Слитые ветки можно удалить командой `git branch -d <имя ветки>`. После этого она не будет
отображаться в выводе команды `git branch` и ветку с таким же именем можно ответвить уже от другого
коммита. При попытке удалить неслитую ветку, Git выдает предупреждение о возможной потере ссылки на
неслитые коммиты. Если это действительно необходимо, и неслитые коммиты можно "забыть", ветку можно
удалить принудительно командой `git branch -D <имя ветки>`.

## Разрешение конфликтов

Если работа в сливаемых ветках велась параллельно, слияние уже не является перемоткой вперед, а
представляет собой коммит, базирующийся сразу на двух родительских коммитах. При этом, если
изменения в ветках затрагивают один и тот же файл, автоматическое слияние возможно только если они
происходили в разных местах файла. Пересекающиеся изменения образуют конфликт, который невозможно
автоматически привести к единому состоянию. Для его разрешения требуется ручное редактирование
затронутых конфликтами файлов.

## Задание для самостоятельной работы
